{"version":3,"file":"main.mjs","sources":["../../output/main-thread/commands/offscreen-canvas.js","../../output/transfer/TransferrableMutation.js","../../output/main-thread/nodes.js","../../output/main-thread/commands/event-subscription.js","../../output/main-thread/commands/bounding-client-rect.js","../../output/main-thread/commands/child-list.js","../../output/main-thread/commands/attribute.js","../../output/main-thread/commands/character-data.js","../../output/main-thread/commands/property.js","../../output/main-thread/commands/long-task.js","../../output/main-thread/deserializeTransferrableObject.js","../../output/main-thread/commands/object-mutation.js","../../output/main-thread/commands/object-creation.js","../../output/main-thread/commands/image-bitmap.js","../../output/main-thread/commands/storage.js","../../output/main-thread/commands/function.js","../../output/main-thread/commands/scroll-into-view.js","../../output/main-thread/mutator.js","../../output/main-thread/strings.js","../../output/main-thread/serialize.js","../../output/main-thread/iframe-worker.js","../../output/main-thread/worker.js","../../output/main-thread/object-context.js","../../output/main-thread/exported-worker.js","../../output/main-thread/install.js","../../output/main-thread/index.amp.js","../../output/utils.js"],"sourcesContent":["export const OffscreenCanvasProcessor = (strings, nodeContext, workerContext, objectContext, config) => {\n    const allowedExecution = config.executorsAllowed.includes(8 /* TransferrableMutationType.OFFSCREEN_CANVAS_INSTANCE */);\n    return {\n        execute(mutations, startPosition, allowedMutation) {\n            if (allowedExecution && allowedMutation) {\n                const targetIndex = mutations[startPosition + 1 /* OffscreenCanvasMutationIndex.Target */];\n                const target = nodeContext.getNode(targetIndex);\n                if (target) {\n                    const offscreen = target.transferControlToOffscreen();\n                    workerContext.messageToWorker({\n                        [12 /* TransferrableKeys.type */]: 9 /* MessageType.OFFSCREEN_CANVAS_INSTANCE */,\n                        [13 /* TransferrableKeys.target */]: [target._index_],\n                        [38 /* TransferrableKeys.data */]: offscreen, // Object, an OffscreenCanvas\n                    }, [offscreen]);\n                }\n                else {\n                    console.error(`'OFFSCREEN_CANVAS_INSTANCE': getNode(${targetIndex}) is null.`);\n                }\n            }\n            return startPosition + 2 /* OffscreenCanvasMutationIndex.End */;\n        },\n        print(mutations, startPosition, target) {\n            return {\n                type: 'OFFSCREEN_CANVAS_INSTANCE',\n                target,\n                allowedExecution,\n            };\n        },\n    };\n};\n//# sourceMappingURL=offscreen-canvas.js.map","/**\n * Returns true if the mutation type can cause a user-visible change to the DOM.\n * @param type\n */\nexport const isUserVisibleMutation = (type) => {\n    switch (type) {\n        case 4 /* TransferrableMutationType.EVENT_SUBSCRIPTION */:\n        case 5 /* TransferrableMutationType.GET_BOUNDING_CLIENT_RECT */:\n        case 6 /* TransferrableMutationType.LONG_TASK_START */:\n        case 7 /* TransferrableMutationType.LONG_TASK_END */:\n        case 12 /* TransferrableMutationType.STORAGE */:\n        case 8 /* TransferrableMutationType.OFFSCREEN_CANVAS_INSTANCE */:\n        case 13 /* TransferrableMutationType.FUNCTION_CALL */:\n            return false;\n        default:\n            return true;\n    }\n};\nexport const DefaultAllowedMutations = [\n    0 /* TransferrableMutationType.ATTRIBUTES */,\n    1 /* TransferrableMutationType.CHARACTER_DATA */,\n    2 /* TransferrableMutationType.CHILD_LIST */,\n    3 /* TransferrableMutationType.PROPERTIES */,\n    4 /* TransferrableMutationType.EVENT_SUBSCRIPTION */,\n    5 /* TransferrableMutationType.GET_BOUNDING_CLIENT_RECT */,\n    6 /* TransferrableMutationType.LONG_TASK_START */,\n    7 /* TransferrableMutationType.LONG_TASK_END */,\n    8 /* TransferrableMutationType.OFFSCREEN_CANVAS_INSTANCE */,\n    9 /* TransferrableMutationType.OBJECT_MUTATION */,\n    10 /* TransferrableMutationType.OBJECT_CREATION */,\n    11 /* TransferrableMutationType.IMAGE_BITMAP_INSTANCE */,\n    12 /* TransferrableMutationType.STORAGE */,\n    13 /* TransferrableMutationType.FUNCTION_CALL */,\n    14 /* TransferrableMutationType.SCROLL_INTO_VIEW */,\n];\nexport const ReadableMutationType = {\n    0: 'ATTRIBUTES',\n    1: 'CHARACTER_DATA',\n    2: 'CHILD_LIST',\n    3: 'PROPERTIES',\n    4: 'EVENT_SUBSCRIPTION',\n    5: 'GET_BOUNDING_CLIENT_RECT',\n    6: 'LONG_TASK_START',\n    7: 'LONG_TASK_END',\n    8: 'OFFSCREEN_CANVAS_INSTANCE',\n    9: 'OBJECT_MUTATION',\n    10: 'OBJECT_CREATION',\n    11: 'IMAGE_BITMAP_INSTANCE',\n    12: 'STORAGE',\n    13: 'FUNCTION_INVOCATION',\n    14: 'SCROLL_INTO_VIEW',\n};\n//# sourceMappingURL=TransferrableMutation.js.map","/**\n * IE11 doesn't support NodeList.prototype.forEach\n * https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach\n * @param list NodeList to iterate over\n * @param callback method to call with each node\n */\nconst nodeListEach = (list, callback) => Array.prototype.forEach.call(list, callback);\nexport const BASE_ELEMENT_INDEX = 1;\nexport class NodeContext {\n    baseElement;\n    stringContext;\n    count;\n    nodes;\n    /**\n     * Called when initializing a Worker, ensures the nodes in baseElement are\n     * known for transmission into the Worker and future mutation events from the\n     * Worker.\n     * @param baseElement Element that will be controlled by a Worker\n     */\n    constructor(stringContext, baseElement) {\n        this.count = 2;\n        this.stringContext = stringContext;\n        // The nodes map is populated with two default values pointing to baseElement.\n        // These are [document, document.body] from the worker.\n        this.nodes = new Map([\n            [BASE_ELEMENT_INDEX, baseElement],\n            [2, baseElement],\n        ]);\n        this.baseElement = baseElement;\n        // To ensure a lookup works correctly from baseElement\n        // add an index equal to the background thread document.body.\n        baseElement._index_ = 2;\n        // Lastly, it's important while initializing the document that we store\n        // the default nodes present in the server rendered document.\n        nodeListEach(baseElement.childNodes, (n) => this.storeNodes(n));\n    }\n    createNodes = (buffer, sanitizer) => {\n        const nodeBuffer = new Uint16Array(buffer);\n        const nodeBufferLength = nodeBuffer.length;\n        for (let iterator = 0; iterator < nodeBufferLength; iterator += 5 /* TransferrableNodeIndex.End */) {\n            let node;\n            if (nodeBuffer[iterator + 1 /* TransferrableNodeIndex.NodeType */] === 3 /* NodeType.TEXT_NODE */) {\n                node = document.createTextNode(this.stringContext.get(nodeBuffer[iterator + 3 /* TransferrableNodeIndex.TextContent */]));\n            }\n            else if (nodeBuffer[iterator + 1 /* TransferrableNodeIndex.NodeType */] === 8 /* NodeType.COMMENT_NODE */) {\n                node = document.createComment(this.stringContext.get(nodeBuffer[iterator + 3 /* TransferrableNodeIndex.TextContent */]));\n            }\n            else if (nodeBuffer[iterator + 1 /* TransferrableNodeIndex.NodeType */] === 11 /* NodeType.DOCUMENT_FRAGMENT_NODE */) {\n                node = document.createDocumentFragment();\n            }\n            else {\n                const nodeName = this.stringContext.get(nodeBuffer[iterator + 2 /* TransferrableNodeIndex.NodeName */]);\n                node =\n                    nodeBuffer[iterator + 4 /* TransferrableNodeIndex.Namespace */] !== 0\n                        ? document.createElementNS(this.stringContext.get(nodeBuffer[iterator + 4 /* TransferrableNodeIndex.Namespace */]), nodeName)\n                        : document.createElement(nodeName);\n                // TODO(KB): Restore Properties\n                // skeleton.properties.forEach(property => {\n                //   node[`${property.name}`] = property.value;\n                // });\n                // ((skeleton as TransferrableElement)[TransferrableKeys.childNodes] || []).forEach(childNode => {\n                //   if (childNode[TransferrableKeys.transferred] === NumericBoolean.FALSE) {\n                //     node.appendChild(this.createNode(childNode as TransferrableNode));\n                //   }\n                // });\n                // If `node` is removed by the sanitizer, don't store it and return null.\n                if (sanitizer && !sanitizer.sanitize(node)) {\n                    continue;\n                }\n            }\n            this.storeNode(node, nodeBuffer[iterator]);\n        }\n    };\n    /**\n     * Returns the real DOM Element corresponding to a serialized Element object.\n     * @param id\n     * @return RenderableElement | null\n     */\n    getNode = (id) => {\n        const node = this.nodes.get(id);\n        if (node && node.nodeName === 'BODY') {\n            // If the node requested is the \"BODY\"\n            // Then we return the base node this specific <amp-script> comes from.\n            // This encapsulates each <amp-script> node.\n            return this.baseElement;\n        }\n        return node;\n    };\n    /**\n     * Store the requested node and all of its children.\n     * @param node node to store.\n     */\n    storeNodes = (node) => {\n        this.storeNode(node, ++this.count);\n        nodeListEach(node.childNodes, (n) => this.storeNodes(n));\n    };\n    /**\n     * Establish link between DOM `node` and worker-generated identifier `id`.\n     *\n     * These _shouldn't_ collide between instances of <amp-script> since\n     * each element creates it's own pool on both sides of the worker\n     * communication bridge.\n     * @param node\n     * @param id\n     */\n    storeNode(node, id) {\n        node._index_ = id;\n        this.nodes.set(id, node);\n    }\n}\n//# sourceMappingURL=nodes.js.map","import { ADD_EVENT_SUBSCRIPTION_LENGTH, REMOVE_EVENT_SUBSCRIPTION_LENGTH, } from '../../transfer/TransferrableEvent';\nimport { BASE_ELEMENT_INDEX } from '../nodes';\n/**\n * Monitoring Nodes attribute changes requires a Mutation Observer.\n * We store the nodes being monitored to avoid creating more than one Observer\n * per Element.\n */\nconst monitoredNodes = new Map();\n/**\n * Instead of a whitelist of elements that need their value tracked, use the existence\n * of a property called value to drive the decision.\n * @param node node to check if values should be tracked.\n * @return boolean if the node should have its value property tracked.\n */\nconst shouldTrackChanges = (node) => node && 'value' in node;\n/**\n * When a node that has a value needing synced doesn't already have an event listener\n * listening for input values, ensure the value is synced with a default listener.\n * @param worker whom to dispatch value toward.\n * @param node node to listen to value changes on.\n */\nexport const applyDefaultInputListener = (workerContext, node) => {\n    if (shouldTrackChanges(node) && node.oninput === null) {\n        node.oninput = () => fireValueChange(workerContext, node);\n    }\n};\n/**\n * Use a MutationObserver to capture value changes based on Attribute modification (frequently used by frameworks).\n * @param worker whom to dispatch value toward.\n * @param node node to listen to value changes on.\n */\nexport const sendValueChangeOnAttributeMutation = (workerContext, node) => {\n    if (shouldTrackChanges(node) && !monitoredNodes.get(node)) {\n        new MutationObserver((mutations) => mutations.map((mutation) => fireValueChange(workerContext, mutation.target))).observe(node, { attributes: true });\n        monitoredNodes.set(node, true);\n    }\n};\n/**\n * Tell WorkerDOM what the value is for a Node.\n * @param worker whom to dispatch value toward.\n * @param node where to get the value from.\n */\nconst fireValueChange = (workerContext, node) => workerContext.messageToWorker({\n    [12 /* TransferrableKeys.type */]: 4 /* MessageType.SYNC */,\n    [40 /* TransferrableKeys.sync */]: {\n        [7 /* TransferrableKeys.index */]: node._index_,\n        [21 /* TransferrableKeys.value */]: node.value,\n    },\n});\n/**\n * Tell WorkerDOM what the window dimensions are.\n * @param workerContext\n * @param cachedWindowSize\n */\nconst fireResizeChange = (workerContext, cachedWindowSize) => workerContext.messageToWorker({\n    [12 /* TransferrableKeys.type */]: 5 /* MessageType.RESIZE */,\n    [40 /* TransferrableKeys.sync */]: cachedWindowSize,\n});\n/**\n * Convert a TouchList into a TransferrableTouchList\n * @param touchList\n */\nconst createTransferrableTouchList = (touchList) => Object.values(touchList).map((touch) => [\n    touch.identifier,\n    touch.screenX,\n    touch.screenY,\n    touch.clientX,\n    touch.clientY,\n    touch.pageX,\n    touch.pageY,\n    touch.target._index_,\n]);\nexport const EventSubscriptionProcessor = (strings, nodeContext, workerContext, objectContext, config) => {\n    const knownListeners = [];\n    const allowedExecution = config.executorsAllowed.includes(4 /* TransferrableMutationType.EVENT_SUBSCRIPTION */);\n    let cachedWindowSize = [window.innerWidth, window.innerHeight];\n    /**\n     * Register an event handler for dispatching events to worker thread\n     * @param worker whom to dispatch events toward\n     * @param index node index the event comes from (used to dispatchEvent in worker thread).\n     * @return eventHandler function consuming event and dispatching to worker thread\n     */\n    const eventHandler = (index, preventDefault) => (event) => {\n        if (preventDefault) {\n            event.preventDefault();\n        }\n        if (shouldTrackChanges(event.currentTarget)) {\n            fireValueChange(workerContext, event.currentTarget);\n        }\n        else if (event.type === 'resize') {\n            const { innerWidth, innerHeight } = window;\n            if (cachedWindowSize[0] === innerWidth && cachedWindowSize[1] === innerHeight) {\n                return;\n            }\n            cachedWindowSize = [window.innerWidth, window.innerHeight];\n            fireResizeChange(workerContext, cachedWindowSize);\n        }\n        workerContext.messageToWorker({\n            [12 /* TransferrableKeys.type */]: 1 /* MessageType.EVENT */,\n            [39 /* TransferrableKeys.event */]: {\n                [7 /* TransferrableKeys.index */]: index,\n                [25 /* TransferrableKeys.bubbles */]: event.bubbles,\n                [26 /* TransferrableKeys.cancelable */]: event.cancelable,\n                [27 /* TransferrableKeys.cancelBubble */]: event.cancelBubble,\n                [28 /* TransferrableKeys.currentTarget */]: [event.currentTarget._index_ || 0],\n                [29 /* TransferrableKeys.defaultPrevented */]: event.defaultPrevented,\n                [30 /* TransferrableKeys.eventPhase */]: event.eventPhase,\n                [31 /* TransferrableKeys.isTrusted */]: event.isTrusted,\n                [32 /* TransferrableKeys.returnValue */]: event.returnValue,\n                [13 /* TransferrableKeys.target */]: [event.target._index_ || 0],\n                [33 /* TransferrableKeys.timeStamp */]: event.timeStamp,\n                [12 /* TransferrableKeys.type */]: event.type,\n                [35 /* TransferrableKeys.keyCode */]: 'keyCode' in event ? event.keyCode : undefined,\n                [60 /* TransferrableKeys.pageX */]: 'pageX' in event ? event.pageX : undefined,\n                [61 /* TransferrableKeys.pageY */]: 'pageY' in event ? event.pageY : undefined,\n                [65 /* TransferrableKeys.offsetX */]: 'offsetX' in event ? event.offsetX : undefined,\n                [66 /* TransferrableKeys.offsetY */]: 'offsetY' in event ? event.offsetY : undefined,\n                [62 /* TransferrableKeys.touches */]: 'touches' in event ? createTransferrableTouchList(event.touches) : undefined,\n                [63 /* TransferrableKeys.changedTouches */]: 'changedTouches' in event ? createTransferrableTouchList(event.changedTouches) : undefined,\n            },\n        });\n    };\n    /**\n     * If the worker requests to add an event listener to 'change' for something the foreground thread is already listening to,\n     * ensure that only a single 'change' event is attached to prevent sending values multiple times.\n     * @param target node to change listeners on\n     * @param addEvent is this an 'addEvent' or 'removeEvent' change\n     * @param mutations Uint16Array for this set of changes\n     * @param iterator current location in array to perform this change on\n     */\n    const processListenerChange = (target, addEvent, mutations, iterator) => {\n        const type = strings.get(mutations[iterator]);\n        const eventIndex = mutations[iterator + 1 /* AddEventRegistrationIndex.Index */];\n        if (target === nodeContext.baseElement) {\n            if (addEvent) {\n                const preventDefault = Boolean(mutations[iterator + 5 /* AddEventRegistrationIndex.WorkerDOMPreventDefault */]);\n                addEventListener(type, (knownListeners[eventIndex] = eventHandler(BASE_ELEMENT_INDEX, preventDefault)));\n            }\n            else {\n                removeEventListener(type, knownListeners[eventIndex]);\n            }\n            return;\n        }\n        let inputEventSubscribed = target.oninput !== null;\n        const isChangeEvent = type === 'change';\n        if (addEvent) {\n            if (isChangeEvent) {\n                inputEventSubscribed = true;\n                target.onchange = null;\n            }\n            const preventDefault = Boolean(mutations[iterator + 5 /* AddEventRegistrationIndex.WorkerDOMPreventDefault */]);\n            target.addEventListener(type, (knownListeners[eventIndex] = eventHandler(target._index_, preventDefault)));\n        }\n        else {\n            if (isChangeEvent) {\n                inputEventSubscribed = false;\n            }\n            target.removeEventListener(type, knownListeners[eventIndex]);\n        }\n        if (shouldTrackChanges(target)) {\n            if (!inputEventSubscribed)\n                applyDefaultInputListener(workerContext, target);\n            sendValueChangeOnAttributeMutation(workerContext, target);\n        }\n    };\n    return {\n        execute(mutations, startPosition, allowedMutation) {\n            const addEventListenerCount = mutations[startPosition + 3 /* EventSubscriptionMutationIndex.AddEventListenerCount */];\n            const removeEventListenerCount = mutations[startPosition + 2 /* EventSubscriptionMutationIndex.RemoveEventListenerCount */];\n            const addEventListenersPosition = startPosition + 4 /* EventSubscriptionMutationIndex.Events */ + removeEventListenerCount * REMOVE_EVENT_SUBSCRIPTION_LENGTH;\n            const endPosition = startPosition +\n                4 /* EventSubscriptionMutationIndex.Events */ +\n                addEventListenerCount * ADD_EVENT_SUBSCRIPTION_LENGTH +\n                removeEventListenerCount * REMOVE_EVENT_SUBSCRIPTION_LENGTH;\n            if (allowedExecution && allowedMutation) {\n                const targetIndex = mutations[startPosition + 1 /* EventSubscriptionMutationIndex.Target */];\n                const target = nodeContext.getNode(targetIndex);\n                if (target) {\n                    let iterator = startPosition + 4 /* EventSubscriptionMutationIndex.Events */;\n                    while (iterator < endPosition) {\n                        const isRemoveEvent = iterator <= addEventListenersPosition;\n                        processListenerChange(target, isRemoveEvent, mutations, iterator);\n                        iterator += isRemoveEvent ? REMOVE_EVENT_SUBSCRIPTION_LENGTH : ADD_EVENT_SUBSCRIPTION_LENGTH;\n                    }\n                }\n                else {\n                    console.error(`getNode(${targetIndex}) is null.`);\n                }\n            }\n            return endPosition;\n        },\n        print(mutations, startPosition) {\n            const addEventListenerCount = mutations[startPosition + 3 /* EventSubscriptionMutationIndex.AddEventListenerCount */];\n            const removeEventListenerCount = mutations[startPosition + 2 /* EventSubscriptionMutationIndex.RemoveEventListenerCount */];\n            const addEventListenersPosition = startPosition + 4 /* EventSubscriptionMutationIndex.Events */ + removeEventListenerCount * REMOVE_EVENT_SUBSCRIPTION_LENGTH;\n            const endPosition = startPosition +\n                4 /* EventSubscriptionMutationIndex.Events */ +\n                addEventListenerCount * ADD_EVENT_SUBSCRIPTION_LENGTH +\n                removeEventListenerCount * REMOVE_EVENT_SUBSCRIPTION_LENGTH;\n            const targetIndex = mutations[startPosition + 1 /* EventSubscriptionMutationIndex.Target */];\n            const target = nodeContext.getNode(targetIndex);\n            const removedEventListeners = [];\n            const addedEventListeners = [];\n            let iterator = startPosition + 4 /* EventSubscriptionMutationIndex.Events */;\n            while (iterator < endPosition) {\n                const isRemoveEvent = iterator <= addEventListenersPosition;\n                const eventList = isRemoveEvent ? addedEventListeners : removedEventListeners;\n                eventList.push({\n                    type: strings.get(mutations[iterator]),\n                    index: mutations[iterator + 1],\n                });\n                iterator += isRemoveEvent ? REMOVE_EVENT_SUBSCRIPTION_LENGTH : ADD_EVENT_SUBSCRIPTION_LENGTH;\n            }\n            return {\n                target,\n                allowedExecution,\n                removedEventListeners,\n                addedEventListeners,\n            };\n        },\n    };\n};\n//# sourceMappingURL=event-subscription.js.map","export const BoundingClientRectProcessor = (strings, nodes, workerContext, objectContext, config) => {\n    const allowedExecution = config.executorsAllowed.includes(5 /* TransferrableMutationType.GET_BOUNDING_CLIENT_RECT */);\n    return {\n        execute(mutations, startPosition, allowedMutation) {\n            if (allowedExecution && allowedMutation) {\n                const targetIndex = mutations[startPosition + 1 /* BoundClientRectMutationIndex.Target */];\n                const target = nodes.getNode(targetIndex);\n                if (target) {\n                    const boundingRect = target.getBoundingClientRect();\n                    workerContext.messageToWorker({\n                        [12 /* TransferrableKeys.type */]: 6 /* MessageType.GET_BOUNDING_CLIENT_RECT */,\n                        [13 /* TransferrableKeys.target */]: [target._index_],\n                        [38 /* TransferrableKeys.data */]: [\n                            boundingRect.top,\n                            boundingRect.right,\n                            boundingRect.bottom,\n                            boundingRect.left,\n                            boundingRect.width,\n                            boundingRect.height,\n                        ],\n                    });\n                }\n                else {\n                    console.error(`GET_BOUNDING_CLIENT_RECT: getNode(${targetIndex}) is null.`);\n                }\n            }\n            return startPosition + 2 /* BoundClientRectMutationIndex.End */;\n        },\n        print(mutations, startPosition) {\n            const targetIndex = mutations[startPosition + 1 /* BoundClientRectMutationIndex.Target */];\n            const target = nodes.getNode(targetIndex);\n            return {\n                type: 'GET_BOUNDING_CLIENT_RECT',\n                target,\n                allowedExecution,\n            };\n        },\n    };\n};\n//# sourceMappingURL=bounding-client-rect.js.map","import { applyDefaultInputListener, sendValueChangeOnAttributeMutation } from './event-subscription';\nexport const ChildListProcessor = (strings, { getNode }, workerContext, objectContext, config) => {\n    const allowedExecution = config.executorsAllowed.includes(2 /* TransferrableMutationType.CHILD_LIST */);\n    return {\n        execute(mutations, startPosition, allowedMutation) {\n            const appendNodeCount = mutations[startPosition + 4 /* ChildListMutationIndex.AppendedNodeCount */];\n            const removeNodeCount = mutations[startPosition + 5 /* ChildListMutationIndex.RemovedNodeCount */];\n            if (allowedExecution && allowedMutation) {\n                const targetIndex = mutations[startPosition + 1 /* ChildListMutationIndex.Target */];\n                const target = getNode(targetIndex);\n                if (target) {\n                    if (removeNodeCount > 0) {\n                        mutations\n                            .slice(startPosition + 6 /* ChildListMutationIndex.Nodes */ + appendNodeCount, startPosition + 6 /* ChildListMutationIndex.Nodes */ + appendNodeCount + removeNodeCount)\n                            .forEach((removeId) => {\n                            const node = getNode(removeId);\n                            if (node) {\n                                node.remove();\n                            }\n                            else {\n                                console.error(`CHILD_LIST: getNode(${removeId}) is null.`);\n                            }\n                        });\n                    }\n                    if (appendNodeCount > 0) {\n                        mutations\n                            .slice(startPosition + 6 /* ChildListMutationIndex.Nodes */, startPosition + 6 /* ChildListMutationIndex.Nodes */ + appendNodeCount)\n                            .forEach((addId) => {\n                            const nextSibling = mutations[startPosition + 2 /* ChildListMutationIndex.NextSibling */];\n                            const newNode = getNode(addId);\n                            if (newNode) {\n                                // TODO: Handle this case ---\n                                // Transferred nodes that are not stored were previously removed by the sanitizer.\n                                target.insertBefore(newNode, (nextSibling && getNode(nextSibling)) || null);\n                                applyDefaultInputListener(workerContext, newNode);\n                                sendValueChangeOnAttributeMutation(workerContext, newNode);\n                            }\n                        });\n                    }\n                }\n                else {\n                    console.error(`CHILD_LIST: getNode(${targetIndex}) is null.`);\n                }\n            }\n            return startPosition + 6 /* ChildListMutationIndex.End */ + appendNodeCount + removeNodeCount;\n        },\n        print(mutations, startPosition) {\n            const targetIndex = mutations[startPosition + 1 /* ChildListMutationIndex.Target */];\n            const target = getNode(targetIndex);\n            const appendNodeCount = mutations[startPosition + 4 /* ChildListMutationIndex.AppendedNodeCount */];\n            const removeNodeCount = mutations[startPosition + 5 /* ChildListMutationIndex.RemovedNodeCount */];\n            const removedNodes = Array.from(mutations.slice(startPosition + 6 /* ChildListMutationIndex.Nodes */ + appendNodeCount, startPosition + 6 /* ChildListMutationIndex.Nodes */ + appendNodeCount + removeNodeCount)).map((index) => getNode(index) || index);\n            const addedNodes = Array.from(mutations.slice(startPosition + 6 /* ChildListMutationIndex.Nodes */, startPosition + 6 /* ChildListMutationIndex.Nodes */ + appendNodeCount)).map((index) => getNode(index) || index);\n            return {\n                target,\n                allowedExecution,\n                nextSibling: getNode(mutations[startPosition + 2 /* ChildListMutationIndex.NextSibling */]) || null,\n                previousSibling: getNode(mutations[startPosition + 3 /* ChildListMutationIndex.PreviousSibling */]) || null,\n                addedNodes,\n                removedNodes,\n            };\n        },\n    };\n};\n//# sourceMappingURL=child-list.js.map","export const AttributeProcessor = (strings, nodes, workerContext, objectContext, config) => {\n    const allowedExecution = config.executorsAllowed.includes(0 /* TransferrableMutationType.ATTRIBUTES */);\n    /**\n     * @param mutations\n     * @param startPosition\n     */\n    const getValue = (mutations, startPosition) => {\n        const value = mutations[startPosition + 4 /* AttributeMutationIndex.Value */];\n        // Value is sent as 0 when it's the default value or removal.\n        // Value is sent as index + 1 when it's a valid value.\n        return value !== 0 ? strings.get(value - 1) : null;\n    };\n    return {\n        execute(mutations, startPosition, allowedMutation) {\n            if (allowedExecution && allowedMutation) {\n                const targetIndex = mutations[startPosition + 1 /* AttributeMutationIndex.Target */];\n                const target = nodes.getNode(targetIndex);\n                const attributeName = strings.get(mutations[startPosition + 2 /* AttributeMutationIndex.Name */]);\n                const value = getValue(mutations, startPosition);\n                if (target) {\n                    if (attributeName != null) {\n                        if (config.sanitizer) {\n                            const mutated = config.sanitizer.setAttribute(target, attributeName, value);\n                            if (!mutated) {\n                                // TODO(choumx): Inform worker that sanitizer ignored unsafe attribute value change.\n                            }\n                        }\n                        else {\n                            if (value == null) {\n                                target.removeAttribute(attributeName);\n                            }\n                            else {\n                                target.setAttribute(attributeName, value);\n                            }\n                        }\n                    }\n                }\n                else {\n                    console.error(`ATTR_LIST: getNode(${targetIndex}) is null.`);\n                }\n            }\n            return startPosition + 5 /* AttributeMutationIndex.End */;\n        },\n        print(mutations, startPosition) {\n            const targetIndex = mutations[startPosition + 1 /* AttributeMutationIndex.Target */];\n            const target = nodes.getNode(targetIndex);\n            const attributeName = strings.get(mutations[startPosition + 2 /* AttributeMutationIndex.Name */]);\n            const value = getValue(mutations, startPosition);\n            return {\n                target,\n                allowedExecution,\n                attributeName,\n                value,\n                remove: value == null,\n            };\n        },\n    };\n};\n//# sourceMappingURL=attribute.js.map","export const CharacterDataProcessor = (strings, nodes, workerContext, objectContext, config) => {\n    const allowedExecution = config.executorsAllowed.includes(1 /* TransferrableMutationType.CHARACTER_DATA */);\n    return {\n        execute(mutations, startPosition, allowedMutation) {\n            if (allowedExecution && allowedMutation) {\n                const targetIndex = mutations[startPosition + 1 /* CharacterDataMutationIndex.Target */];\n                const target = nodes.getNode(targetIndex);\n                const value = mutations[startPosition + 2 /* CharacterDataMutationIndex.Value */];\n                if (target) {\n                    if (value) {\n                        // Sanitization not necessary for textContent.\n                        target.textContent = strings.get(value);\n                    }\n                }\n                else {\n                    console.error(`CHAR_DATA: getNode(${targetIndex}) is null.`);\n                }\n            }\n            return startPosition + 3 /* CharacterDataMutationIndex.End */;\n        },\n        print(mutations, startPosition) {\n            const targetIndex = mutations[startPosition + 1 /* CharacterDataMutationIndex.Target */];\n            const target = nodes.getNode(targetIndex);\n            return {\n                target,\n                allowedExecution,\n                value: strings.get(mutations[startPosition + 2 /* CharacterDataMutationIndex.Value */]),\n            };\n        },\n    };\n};\n//# sourceMappingURL=character-data.js.map","export const PropertyProcessor = (strings, nodeContext, workerContext, objectContext, config) => {\n    const allowedExecution = config.executorsAllowed.includes(3 /* TransferrableMutationType.PROPERTIES */);\n    const getValue = (mutations, startPosition) => {\n        const value = mutations[startPosition + 4 /* PropertyMutationIndex.Value */];\n        if (mutations[startPosition + 3 /* PropertyMutationIndex.IsBoolean */] === 1 /* NumericBoolean.TRUE */) {\n            return value === 1 /* NumericBoolean.TRUE */;\n        }\n        if (value !== 0) {\n            return strings.get(value);\n        }\n        return null;\n    };\n    return {\n        execute(mutations, startPosition, allowedMutation) {\n            if (allowedExecution && allowedMutation) {\n                const targetIndex = mutations[startPosition + 1 /* PropertyMutationIndex.Target */];\n                const target = nodeContext.getNode(targetIndex);\n                const name = strings.get(mutations[startPosition + 2 /* PropertyMutationIndex.Name */]);\n                const value = getValue(mutations, startPosition);\n                if (target) {\n                    if (name && value != null) {\n                        if (config.sanitizer) {\n                            const mutated = config.sanitizer.setProperty(target, name, String(value));\n                            if (!mutated) {\n                                // TODO(choumx): Inform worker that sanitizer ignored unsafe property value change.\n                            }\n                        }\n                        else {\n                            target[name] = value;\n                        }\n                    }\n                }\n                else {\n                    console.error(`PROPERTY: getNode(${targetIndex}) is null.`);\n                }\n            }\n            return startPosition + 5 /* PropertyMutationIndex.End */;\n        },\n        print(mutations, startPosition) {\n            const targetIndex = mutations[startPosition + 1 /* PropertyMutationIndex.Target */];\n            const target = nodeContext.getNode(targetIndex);\n            const name = strings.get(mutations[startPosition + 2 /* PropertyMutationIndex.Name */]);\n            const value = getValue(mutations, startPosition);\n            return {\n                target,\n                name,\n                value,\n                allowedExecution,\n            };\n        },\n    };\n};\n//# sourceMappingURL=property.js.map","import { ReadableMutationType } from '../../transfer/TransferrableMutation';\nexport const LongTaskExecutor = (stringContext, nodeContext, workerContext, objectContext, config) => {\n    const allowedExecution = config.executorsAllowed.includes(6 /* TransferrableMutationType.LONG_TASK_START */);\n    let index = 0;\n    let currentResolver;\n    return {\n        execute(mutations, startPosition, allowedMutation) {\n            if (allowedExecution && allowedMutation && config.longTask) {\n                if (mutations[startPosition] === 6 /* TransferrableMutationType.LONG_TASK_START */) {\n                    index++;\n                    if (!currentResolver) {\n                        const newResolver = new Promise((resolve) => (currentResolver = resolve));\n                        // One of the worker-dom contracts is that there should not be two\n                        // LONG_TASK_STARTs in a row without an END in between. In case both exist within\n                        // the same set of mutations, we need to guard against having a consumers 1st END\n                        // handler occur after the START handler. If we synchronously called longTask() here it\n                        // would likely occur due to scheduling of callbacks vs. promise.\n                        // See: worker-dom/pull/989.\n                        Promise.resolve().then(() => config.longTask && config.longTask(newResolver));\n                    }\n                }\n                else if (mutations[startPosition] === 7 /* TransferrableMutationType.LONG_TASK_END */) {\n                    index--;\n                    if (currentResolver && index <= 0) {\n                        currentResolver();\n                        currentResolver = null;\n                        index = 0;\n                    }\n                }\n            }\n            return startPosition + 2 /* LongTaskMutationIndex.End */;\n        },\n        print(mutations, startPosition) {\n            return {\n                type: ReadableMutationType[mutations[startPosition]],\n                allowedExecution,\n            };\n        },\n        get active() {\n            return currentResolver !== null;\n        },\n    };\n};\n//# sourceMappingURL=long-task.js.map","const f32 = new Float32Array(1);\nconst u16 = new Uint16Array(f32.buffer);\n/**\n * Deserializes TransferrableObjectType arguments.\n * @param buffer Contains mutation with arguments to deserialize.\n * @param offset Start position of arguments in mutations buffer.\n * @param count Number of arguments to deserialize.\n * @param stringContext Strings context.\n * @param nodeContext Nodes context.\n * @param objectContext Objects context\n */\nexport function deserializeTransferrableObject(buffer, offset, count, stringContext, nodeContext, objectContext) {\n    const args = [];\n    for (let i = 0; i < count; i++) {\n        switch (buffer[offset++]) {\n            case 1 /* TransferrableObjectType.SmallInt */:\n                args.push(buffer[offset++]);\n                break;\n            case 2 /* TransferrableObjectType.Float */:\n                u16[0] = buffer[offset++];\n                u16[1] = buffer[offset++];\n                args.push(f32[0]);\n                break;\n            case 3 /* TransferrableObjectType.String */:\n                args.push(stringContext.get(buffer[offset++]));\n                break;\n            case 4 /* TransferrableObjectType.Array */:\n                const size = buffer[offset++];\n                const des = deserializeTransferrableObject(buffer, offset, size, stringContext, nodeContext, objectContext);\n                args.push(des.args);\n                offset = des.offset;\n                break;\n            case 5 /* TransferrableObjectType.TransferObject */:\n                if (!objectContext) {\n                    throw new Error('objectContext not provided.');\n                }\n                args.push(objectContext.get(buffer[offset++]));\n                break;\n            case 6 /* TransferrableObjectType.CanvasRenderingContext2D */:\n                const canvas = nodeContext.getNode(buffer[offset++]);\n                args.push(canvas.getContext('2d'));\n                break;\n            case 7 /* TransferrableObjectType.HTMLElement */:\n                args.push(nodeContext.getNode(buffer[offset++]));\n                break;\n            default:\n                throw new Error('Cannot deserialize argument.');\n        }\n    }\n    return {\n        args,\n        offset,\n    };\n}\n//# sourceMappingURL=deserializeTransferrableObject.js.map","import { deserializeTransferrableObject } from '../deserializeTransferrableObject';\nexport const ObjectMutationProcessor = (strings, nodeContext, workerContext, objectContext, config) => {\n    const allowedExecution = config.executorsAllowed.includes(9 /* TransferrableMutationType.OBJECT_MUTATION */);\n    return {\n        execute(mutations, startPosition, allowedMutation) {\n            const functionName = strings.get(mutations[startPosition + 1 /* ObjectMutationIndex.FunctionName */]);\n            const argCount = mutations[startPosition + 2 /* ObjectMutationIndex.ArgumentCount */];\n            const { offset: targetOffset, args: deserializedTarget } = deserializeTransferrableObject(mutations, startPosition + 3 /* ObjectMutationIndex.SerializedTarget */, 1, strings, nodeContext, objectContext);\n            const target = deserializedTarget[0];\n            const { offset: argsOffset, args } = deserializeTransferrableObject(mutations, targetOffset, argCount, strings, nodeContext, objectContext);\n            if (allowedExecution && allowedMutation) {\n                if (isSetter(target, functionName)) {\n                    target[functionName] = args[0];\n                }\n                else {\n                    target[functionName](...args);\n                }\n            }\n            return argsOffset;\n        },\n        print(mutations, startPosition) {\n            const functionName = strings.get(mutations[startPosition + 1 /* ObjectMutationIndex.FunctionName */]);\n            const { args: deserializedTarget } = deserializeTransferrableObject(mutations, startPosition + 3 /* ObjectMutationIndex.SerializedTarget */, 1, strings, nodeContext, objectContext);\n            const target = deserializedTarget[0];\n            return {\n                type: 'OBJECT_MUTATION',\n                target,\n                functionName,\n                isSetter: isSetter(target, functionName),\n                allowedExecution,\n            };\n        },\n    };\n};\nfunction isSetter(object, name) {\n    if (!object) {\n        throw new Error(`Property ${name} does not exist on ${object}.`);\n    }\n    const descriptor = Object.getOwnPropertyDescriptor(object, name);\n    if (descriptor !== undefined) {\n        return 'set' in descriptor;\n    }\n    return isSetter(Object.getPrototypeOf(object), name);\n}\n//# sourceMappingURL=object-mutation.js.map","import { deserializeTransferrableObject } from '../deserializeTransferrableObject';\nexport const ObjectCreationProcessor = (strings, nodeContext, workerContext, objectContext, config) => {\n    const allowedExecution = config.executorsAllowed.includes(10 /* TransferrableMutationType.OBJECT_CREATION */);\n    if (!objectContext) {\n        throw new Error('objectContext is not defined.');\n    }\n    return {\n        execute(mutations, startPosition, allowedMutation) {\n            const functionName = strings.get(mutations[startPosition + 1 /* ObjectCreationIndex.FunctionName */]);\n            const objectId = mutations[startPosition + 2 /* ObjectCreationIndex.ObjectId */];\n            const argCount = mutations[startPosition + 3 /* ObjectCreationIndex.ArgumentCount */];\n            const { offset: targetOffset, args: deserializedTarget } = deserializeTransferrableObject(mutations, startPosition + 4 /* ObjectCreationIndex.SerializedTarget */, 1, // argCount\n            strings, nodeContext, objectContext);\n            const target = deserializedTarget[0];\n            const { offset: argsOffset, args } = deserializeTransferrableObject(mutations, targetOffset, argCount, strings, nodeContext, objectContext);\n            if (allowedExecution && allowedMutation) {\n                if (functionName === 'new') {\n                    // deal with constructor case here\n                }\n                else {\n                    objectContext.store(objectId, target[functionName](...args));\n                }\n            }\n            return argsOffset;\n        },\n        print(mutations, startPosition) {\n            const functionName = strings.get(mutations[startPosition + 1 /* ObjectCreationIndex.FunctionName */]);\n            const objectId = mutations[startPosition + 2 /* ObjectCreationIndex.ObjectId */];\n            const argCount = mutations[startPosition + 3 /* ObjectCreationIndex.ArgumentCount */];\n            const { args: deserializedTarget } = deserializeTransferrableObject(mutations, startPosition + 4 /* ObjectCreationIndex.SerializedTarget */, 1, // argCount\n            strings, nodeContext, objectContext);\n            const target = deserializedTarget[0];\n            return {\n                type: 'OBJECT_CREATION',\n                target,\n                functionName,\n                objectId,\n                argCount,\n                allowedExecution,\n            };\n        },\n    };\n};\n//# sourceMappingURL=object-creation.js.map","export const ImageBitmapProcessor = (strings, nodeContext, workerContext, objectContext, config) => {\n    const allowedExecution = config.executorsAllowed.includes(11 /* TransferrableMutationType.IMAGE_BITMAP_INSTANCE */);\n    return {\n        execute(mutations, startPosition, allowedMutation) {\n            if (allowedExecution && allowedMutation) {\n                const targetIndex = mutations[startPosition + 1 /* ImageBitmapMutationIndex.Target */];\n                const target = nodeContext.getNode(targetIndex);\n                if (target) {\n                    self.createImageBitmap(target).then((imageBitmap) => {\n                        workerContext.messageToWorker({\n                            [12 /* TransferrableKeys.type */]: 10 /* MessageType.IMAGE_BITMAP_INSTANCE */,\n                            [73 /* TransferrableKeys.callIndex */]: mutations[startPosition + 2 /* ImageBitmapMutationIndex.CallIndex */],\n                            [38 /* TransferrableKeys.data */]: imageBitmap,\n                        }, [imageBitmap]);\n                    });\n                }\n                else {\n                    console.error(`IMAGE_BITMAP_INSTANCE: getNode(${targetIndex}) is null.`);\n                }\n            }\n            return startPosition + 3 /* ImageBitmapMutationIndex.End */;\n        },\n        print(mutations, startPosition) {\n            const targetIndex = mutations[startPosition + 1 /* ImageBitmapMutationIndex.Target */];\n            const target = nodeContext.getNode(targetIndex);\n            return {\n                type: 'IMAGE_BITMAP_INSTANCE',\n                target,\n                allowedExecution,\n                callIndex: mutations[startPosition + 2 /* ImageBitmapMutationIndex.CallIndex */],\n            };\n        },\n    };\n};\n//# sourceMappingURL=image-bitmap.js.map","export const StorageProcessor = (strings, nodeContext, workerContext, objectContext, config) => {\n    const allowedExecution = config.executorsAllowed.includes(12 /* TransferrableMutationType.STORAGE */);\n    const get = (location, key) => {\n        if (config.sanitizer && location === 2 /* StorageLocation.AmpState */) {\n            config.sanitizer.getStorage(location, key).then((value) => {\n                const message = {\n                    [12 /* TransferrableKeys.type */]: 11 /* MessageType.GET_STORAGE */,\n                    [74 /* TransferrableKeys.storageKey */]: key,\n                    [75 /* TransferrableKeys.storageLocation */]: location,\n                    [21 /* TransferrableKeys.value */]: value,\n                };\n                workerContext.messageToWorker(message);\n            });\n        }\n        else {\n            console.error(`STORAGE: Sanitizer not found or unsupported location:`, location);\n        }\n    };\n    const set = (location, key, value) => {\n        if (config.sanitizer) {\n            // TODO: Message worker so AMP.setState() can be Promise-able.\n            config.sanitizer.setStorage(location, key, value);\n        }\n        else {\n            let storage;\n            if (location === 0 /* StorageLocation.Local */) {\n                storage = window.localStorage;\n            }\n            else if (location === 1 /* StorageLocation.Session */) {\n                storage = window.sessionStorage;\n            }\n            if (storage) {\n                if (key == null) {\n                    if (value == null) {\n                        storage.clear();\n                    }\n                    else {\n                        throw new Error('Unexpected storage operation.');\n                    }\n                }\n                else {\n                    if (value == null) {\n                        storage.removeItem(key);\n                    }\n                    else {\n                        storage.setItem(key, value);\n                    }\n                }\n            }\n            else {\n                console.error(`STORAGE: Unexpected location: \"${location}\".`);\n            }\n        }\n    };\n    return {\n        execute(mutations, startPosition, allowedMutation) {\n            if (allowedExecution && allowedMutation) {\n                const operation = mutations[startPosition + 1 /* StorageMutationIndex.Operation */];\n                const location = mutations[startPosition + 2 /* StorageMutationIndex.Location */];\n                const keyIndex = mutations[startPosition + 3 /* StorageMutationIndex.Key */];\n                const valueIndex = mutations[startPosition + 4 /* StorageMutationIndex.Value */];\n                // TODO(choumx): Clean up key/value strings (or don't store them in the first place)\n                // to avoid leaking memory.\n                const key = keyIndex > 0 ? strings.get(keyIndex - 1) : '';\n                const value = valueIndex > 0 ? strings.get(valueIndex - 1) : null;\n                if (operation === 1 /* GetOrSet.GET */) {\n                    get(location, key);\n                }\n                else if (operation === 2 /* GetOrSet.SET */) {\n                    set(location, key, value);\n                }\n            }\n            return startPosition + 5 /* StorageMutationIndex.End */;\n        },\n        print(mutations, startPosition) {\n            const operation = mutations[startPosition + 1 /* StorageMutationIndex.Operation */];\n            const location = mutations[startPosition + 2 /* StorageMutationIndex.Location */];\n            const keyIndex = mutations[startPosition + 3 /* StorageMutationIndex.Key */];\n            const valueIndex = mutations[startPosition + 4 /* StorageMutationIndex.Value */];\n            const key = keyIndex > 0 ? strings.get(keyIndex - 1) : null;\n            const value = valueIndex > 0 ? strings.get(valueIndex - 1) : null;\n            return {\n                type: 'STORAGE',\n                operation,\n                location,\n                key,\n                value,\n                allowedExecution,\n            };\n        },\n    };\n};\n//# sourceMappingURL=storage.js.map","let fnCallCount = 0;\n/**\n * A mapping between each request to callFunction and its Promise.\n */\nconst promiseMap = {};\n/**\n * Each invocation of `ExportedWorker.prototype.callFunction` needs to be registered with a unique index\n * and promise. The index is given to the underlying Worker and returned by it as well. That enables the main-thread to\n * correlate postMessage responses with their original requests and resolve/reject the correct Promise.\n */\nexport function registerPromise() {\n    // TS won't realize that the constructor promise assigns the handlers, so we `any` them.\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    // Wraparound to 0 in case someone attempts to register over 9 quadrillion promises.\n    if (fnCallCount >= Number.MAX_VALUE) {\n        fnCallCount = 0;\n    }\n    const index = fnCallCount++;\n    promiseMap[index] = { promise, resolve, reject };\n    return { promise, index };\n}\nexport const FunctionProcessor = (strings, nodeContext, workerContext, objectContext, config) => {\n    const allowedExecution = config.executorsAllowed.includes(13 /* TransferrableMutationType.FUNCTION_CALL */);\n    return {\n        execute(mutations, startPosition) {\n            if (allowedExecution) {\n                const status = mutations[startPosition + 1 /* FunctionMutationIndex.Status */];\n                const index = mutations[startPosition + 2 /* FunctionMutationIndex.Index */];\n                const value = mutations[startPosition + 3 /* FunctionMutationIndex.Value */];\n                const parsed = strings.hasIndex(value) ? JSON.parse(strings.get(value)) : undefined;\n                if (status === 1 /* ResolveOrReject.RESOLVE */) {\n                    promiseMap[index].resolve(parsed);\n                }\n                else {\n                    promiseMap[index].reject(parsed);\n                }\n                delete promiseMap[index];\n            }\n            return startPosition + 4 /* FunctionMutationIndex.End */;\n        },\n        print(mutations, startPosition) {\n            const status = mutations[startPosition + 1 /* FunctionMutationIndex.Status */];\n            const index = mutations[startPosition + 2 /* FunctionMutationIndex.Index */];\n            const value = mutations[startPosition + 3 /* FunctionMutationIndex.Value */];\n            return {\n                type: 'FUNCTION_INVOCATION',\n                status,\n                index,\n                value: strings.get(value),\n                allowedExecution,\n            };\n        },\n    };\n};\n//# sourceMappingURL=function.js.map","export const ScrollIntoViewProcessor = (strings, nodes, workerContext, objectContext, config) => {\n    const allowedExecution = config.executorsAllowed.includes(14 /* TransferrableMutationType.SCROLL_INTO_VIEW */);\n    return {\n        execute(mutations, startPosition, allowedMutation) {\n            if (allowedExecution && allowedMutation) {\n                const targetIndex = mutations[startPosition + 1 /* ScrollIntoViewMutationIndex.Target */];\n                const target = nodes.getNode(targetIndex);\n                if (target) {\n                    target.scrollIntoView();\n                }\n                else {\n                    console.error(`SCROLL_INTO_VIEW: getNode(${targetIndex}) is null.`);\n                }\n            }\n            return startPosition + 2 /* ScrollIntoViewMutationIndex.End */;\n        },\n        print(mutations, startPosition) {\n            const targetIndex = mutations[startPosition + 1 /* ScrollIntoViewMutationIndex.Target */];\n            const target = nodes.getNode(targetIndex);\n            return {\n                type: 'SCROLL_INTO_VIEW',\n                target,\n                allowedExecution,\n            };\n        },\n    };\n};\n//# sourceMappingURL=scroll-into-view.js.map","import { OffscreenCanvasProcessor } from './commands/offscreen-canvas';\nimport { ReadableMutationType, isUserVisibleMutation } from '../transfer/TransferrableMutation';\nimport { EventSubscriptionProcessor } from './commands/event-subscription';\nimport { BoundingClientRectProcessor } from './commands/bounding-client-rect';\nimport { ChildListProcessor } from './commands/child-list';\nimport { AttributeProcessor } from './commands/attribute';\nimport { CharacterDataProcessor } from './commands/character-data';\nimport { PropertyProcessor } from './commands/property';\nimport { LongTaskExecutor } from './commands/long-task';\nimport { ObjectMutationProcessor } from './commands/object-mutation';\nimport { ObjectCreationProcessor } from './commands/object-creation';\nimport { ImageBitmapProcessor } from './commands/image-bitmap';\nimport { StorageProcessor } from './commands/storage';\nimport { FunctionProcessor } from './commands/function';\nimport { ScrollIntoViewProcessor } from './commands/scroll-into-view';\nexport class MutatorProcessor {\n    stringContext;\n    nodeContext;\n    mutationQueue = [];\n    pendingMutations = false;\n    mutationPumpFunction;\n    sanitizer;\n    executors;\n    /**\n     * @param stringContext\n     * @param nodeContext\n     * @param workerContext\n     * @param sanitizer Sanitizer to apply to content if needed.\n     */\n    constructor(stringContext, nodeContext, workerContext, config, objectContext) {\n        this.stringContext = stringContext;\n        this.nodeContext = nodeContext;\n        this.sanitizer = config.sanitizer;\n        this.mutationPumpFunction = config.mutationPump;\n        const args = [\n            stringContext,\n            nodeContext,\n            workerContext,\n            objectContext,\n            config,\n        ];\n        const sharedLongTaskProcessor = LongTaskExecutor.apply(null, args);\n        this.executors = {\n            [2 /* TransferrableMutationType.CHILD_LIST */]: ChildListProcessor.apply(null, args),\n            [0 /* TransferrableMutationType.ATTRIBUTES */]: AttributeProcessor.apply(null, args),\n            [1 /* TransferrableMutationType.CHARACTER_DATA */]: CharacterDataProcessor.apply(null, args),\n            [3 /* TransferrableMutationType.PROPERTIES */]: PropertyProcessor.apply(null, args),\n            [4 /* TransferrableMutationType.EVENT_SUBSCRIPTION */]: EventSubscriptionProcessor.apply(null, args),\n            [5 /* TransferrableMutationType.GET_BOUNDING_CLIENT_RECT */]: BoundingClientRectProcessor.apply(null, args),\n            [6 /* TransferrableMutationType.LONG_TASK_START */]: sharedLongTaskProcessor,\n            [7 /* TransferrableMutationType.LONG_TASK_END */]: sharedLongTaskProcessor,\n            [8 /* TransferrableMutationType.OFFSCREEN_CANVAS_INSTANCE */]: OffscreenCanvasProcessor.apply(null, args),\n            [9 /* TransferrableMutationType.OBJECT_MUTATION */]: ObjectMutationProcessor.apply(null, args),\n            [10 /* TransferrableMutationType.OBJECT_CREATION */]: ObjectCreationProcessor.apply(null, args),\n            [11 /* TransferrableMutationType.IMAGE_BITMAP_INSTANCE */]: ImageBitmapProcessor.apply(null, args),\n            [12 /* TransferrableMutationType.STORAGE */]: StorageProcessor.apply(null, args),\n            [13 /* TransferrableMutationType.FUNCTION_CALL */]: FunctionProcessor.apply(null, args),\n            [14 /* TransferrableMutationType.SCROLL_INTO_VIEW */]: ScrollIntoViewProcessor.apply(null, args),\n        };\n    }\n    /**\n     * Process MutationRecords from worker thread applying changes to the existing DOM.\n     * @param phase Current Phase Worker Thread exists in.\n     * @param nodes New nodes to add in the main thread with the incoming mutations.\n     * @param stringValues Additional string values to use in decoding messages.\n     * @param mutations Changes to apply in both graph shape and content of Elements.\n     */\n    mutate(phase, nodes, stringValues, mutations) {\n        this.stringContext.storeValues(stringValues);\n        this.nodeContext.createNodes(nodes, this.sanitizer);\n        this.mutationQueue = this.mutationQueue.concat(mutations);\n        if (!this.pendingMutations) {\n            this.pendingMutations = true;\n            this.mutationPumpFunction(this.syncFlush, phase);\n        }\n    }\n    /**\n     * Apply all stored mutations syncronously. This method works well, but can cause jank if there are too many\n     * mutations to apply in a single frame.\n     *\n     * Investigations in using asyncFlush to resolve are worth considering.\n     *\n     * @param allowVisibleMutations\n     * @return Array of mutation types that were disallowed.\n     */\n    syncFlush = (allowVisibleMutations = true) => {\n        if (WORKER_DOM_DEBUG) {\n            console.group('Mutations');\n        }\n        const disallowedMutations = [];\n        this.mutationQueue.forEach((mutationArray) => {\n            const length = mutationArray.length;\n            let operationStart = 0;\n            while (operationStart < length) {\n                // TransferrableMutationType is always at position 0.\n                const mutationType = mutationArray[operationStart];\n                // TODO(worker-dom): Hoist `allow` up to entry point (index.amp.ts) to avoid bundling `isUserVisibleMutation`.\n                const allow = allowVisibleMutations || !isUserVisibleMutation(mutationType);\n                if (!allow) {\n                    // TODO(worker-dom): Consider returning the strings from executor.print() for better error messaging.\n                    disallowedMutations.push(mutationType);\n                }\n                const executor = this.executors[mutationType];\n                if (WORKER_DOM_DEBUG) {\n                    console.log(allow ? '' : '[disallowed]', ReadableMutationType[mutationType], executor.print(mutationArray, operationStart));\n                }\n                operationStart = executor.execute(mutationArray, operationStart, allow);\n            }\n        });\n        if (WORKER_DOM_DEBUG) {\n            console.groupEnd();\n        }\n        this.mutationQueue = [];\n        this.pendingMutations = false;\n        return disallowedMutations;\n    };\n}\n//# sourceMappingURL=mutator.js.map","/**\n * Stores indexed strings that are used in postMessage() calls from the worker.\n */\nexport class StringContext {\n    strings;\n    constructor() {\n        this.strings = [];\n    }\n    /**\n     * Return a string for the specified index.\n     * @param index string index to retrieve.\n     * @return string in map for the index.\n     */\n    get(index) {\n        return this.strings[index] || '';\n    }\n    hasIndex(index) {\n        return this.strings[index] !== undefined;\n    }\n    /**\n     * Stores a string in mapping and returns the index of the location.\n     * @param value string to store\n     * @return {number}\n     */\n    store(value) {\n        this.strings.push(value);\n        return this.strings.length - 1;\n    }\n    /**\n     * Stores a set of strings.\n     * @param values\n     */\n    storeValues(values) {\n        values.forEach((v) => this.store(v));\n    }\n}\n//# sourceMappingURL=strings.js.map","import { applyDefaultInputListener, sendValueChangeOnAttributeMutation } from './commands/event-subscription';\nconst NODES_ALLOWED_TO_TRANSMIT_TEXT_CONTENT = [8 /* NodeType.COMMENT_NODE */, 3 /* NodeType.TEXT_NODE */];\n/**\n * Serializes a DOM element for transport to the worker.\n * @param element\n * @param minimizeString Function for minimizing strings for optimized ferrying across postMessage.\n */\nfunction createHydrateableNode(element, minimizeString, hydrateFilter, workerContext) {\n    const filteredChildNodes = [].slice.call(element.childNodes).filter(hydrateFilter);\n    const hydrated = {\n        [7 /* TransferrableKeys.index */]: element._index_,\n        [11 /* TransferrableKeys.transferred */]: 0 /* NumericBoolean.FALSE */,\n        [0 /* TransferrableKeys.nodeType */]: element.nodeType,\n        [1 /* TransferrableKeys.localOrNodeName */]: minimizeString(element.localName || element.nodeName),\n        [4 /* TransferrableKeys.childNodes */]: filteredChildNodes.map((child) => createHydrateableNode(child, minimizeString, hydrateFilter, workerContext)),\n        [2 /* TransferrableKeys.attributes */]: [].map.call(element.attributes || [], (attribute) => [\n            minimizeString(attribute.namespaceURI || 'null'),\n            minimizeString(attribute.name),\n            minimizeString(attribute.value),\n        ]),\n    };\n    if (element.namespaceURI != null) {\n        hydrated[6 /* TransferrableKeys.namespaceURI */] = minimizeString(element.namespaceURI);\n    }\n    if (NODES_ALLOWED_TO_TRANSMIT_TEXT_CONTENT.includes(element.nodeType) && element.textContent !== null) {\n        hydrated[5 /* TransferrableKeys.textContent */] = minimizeString(element.textContent);\n    }\n    applyDefaultInputListener(workerContext, element);\n    sendValueChangeOnAttributeMutation(workerContext, element);\n    return hydrated;\n}\n/**\n * @param element\n */\nexport function createHydrateableRootNode(element, config, workerContext) {\n    const hydrateFilter = config.hydrateFilter || (() => true);\n    const strings = [];\n    const stringMap = new Map();\n    const storeString = (value) => {\n        if (stringMap.has(value)) {\n            // Safe to cast since we verified the mapping contains the value.\n            return stringMap.get(value);\n        }\n        const count = strings.length;\n        stringMap.set(value, count);\n        strings.push(value);\n        return count;\n    };\n    const skeleton = createHydrateableNode(element, storeString, hydrateFilter, workerContext);\n    return { skeleton, strings };\n}\n/**\n * @param element\n */\nexport function createReadableHydrateableRootNode(element, config, workerContext) {\n    // \"Readable\" variant doesn't do any string minimization so we can output it for debugging purposes.\n    // Note that this intentionally breaks the type contract of createHydrateableNode() and HydrateableNode.\n    return createHydrateableNode(element, ((value) => value), config.hydrateFilter || (() => true), workerContext);\n}\n//# sourceMappingURL=serialize.js.map","/**\n * An almost drop-in replacement for a standard Web Worker, although this one\n * within a sandboxed cross-origin iframe for a heightened security boundary.\n * For more details on Worker, see: https://developer.mozilla.org/en-US/docs/Web/API/Worker\n *\n * The iframe used for sandboxing must follow a specific contract. It:\n *   1. Must send a ready message to the main-thread.\n *   2. Must listen for a message from main-thread with the code to initialize a Worker with.\n *   3. Must send \"worker-ready\" once worker is initialized.\n *   4. Must proxy all messages between the Worker and Parent, including errors.\n */\nclass IframeWorker {\n    url;\n    // Public Worker API\n    onerror;\n    onmessage;\n    onmessageerror;\n    readyPromise;\n    // Internal variables.\n    iframe;\n    readyPromiseResolve;\n    /**\n     * @param url The URL to initiate the worker from.\n     * @param iframeUrl The URL of the iframe to use as the worker proxy.\n     */\n    constructor(url, iframeUrl) {\n        this.url = url;\n        this.iframe = window.document.createElement('iframe');\n        this.iframe.setAttribute('sandbox', 'allow-scripts');\n        this.iframe.setAttribute('style', 'display:none');\n        this.iframe.setAttribute('src', iframeUrl);\n        this.url = url;\n        this.readyPromise = new Promise((resolve) => {\n            this.readyPromiseResolve = resolve;\n        });\n        this.setupInit();\n        this.proxyFromWorker();\n        window.document.body.appendChild(this.iframe);\n    }\n    setupInit() {\n        const listener = (event) => {\n            if (event.source != this.iframe.contentWindow) {\n                return;\n            }\n            fetch(this.url.toString())\n                .then((res) => res.text())\n                .then((code) => {\n                const data = event.data;\n                if (data.type == 'iframe-ready') {\n                    const msg = { type: 'init-worker', code };\n                    this.iframe.contentWindow.postMessage(msg, '*');\n                }\n                else if (data.type === 'worker-ready') {\n                    this.readyPromiseResolve();\n                    window.removeEventListener('message', listener);\n                }\n            });\n        };\n        window.addEventListener('message', listener);\n    }\n    proxyFromWorker() {\n        window.addEventListener('message', (event) => {\n            if (event.source != this.iframe.contentWindow) {\n                return;\n            }\n            const { type, message } = event.data;\n            if (type == 'onmessage' && this.onmessage) {\n                this.onmessage({ ...event, data: message });\n            }\n            else if (type === 'onerror' && this.onerror) {\n                this.onerror(message);\n            }\n            else if (type === 'onmessageerror' && this.onmessageerror) {\n                this.onmessageerror({ ...event, data: message });\n            }\n        });\n    }\n    /**\n     * See https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage\n     * @param message\n     * @param transferables\n     */\n    postMessage(message, transferables) {\n        const msg = { type: 'postMessage', message };\n        this.readyPromise.then(() => {\n            this.iframe.contentWindow.postMessage(msg, '*', transferables);\n        });\n    }\n    /**\n     * See https://developer.mozilla.org/en-US/docs/Web/API/Worker/terminate\n     */\n    terminate() {\n        const msg = { type: 'terminate' };\n        this.iframe.contentWindow.postMessage(msg, '*');\n        this.iframe.remove();\n    }\n}\nexport { IframeWorker };\n//# sourceMappingURL=iframe-worker.js.map","import { createHydrateableRootNode } from './serialize';\nimport { readableHydrateableRootNode, readableMessageToWorker } from './debugging';\nimport { IframeWorker } from './iframe-worker';\nexport class WorkerContext {\n    [55 /* TransferrableKeys.worker */];\n    nodeContext;\n    config;\n    /**\n     * @param baseElement\n     * @param nodeContext\n     * @param workerDOMScript\n     * @param authorScript\n     * @param config\n     */\n    constructor(baseElement, nodeContext, workerDOMScript, authorScript, config) {\n        this.nodeContext = nodeContext;\n        this.config = config;\n        const { skeleton, strings } = createHydrateableRootNode(baseElement, config, this);\n        const cssKeys = [];\n        const globalEventHandlerKeys = [];\n        // TODO(choumx): Sync read of all localStorage and sessionStorage a possible performance bottleneck?\n        const localStorageInit = getStorageInit('localStorage');\n        const sessionStorageInit = getStorageInit('sessionStorage');\n        for (const key in baseElement.style) {\n            cssKeys.push(key);\n        }\n        for (const key in baseElement) {\n            if (key.startsWith('on')) {\n                globalEventHandlerKeys.push(key);\n            }\n        }\n        // We skip assigning the globals for localStorage and sessionStorage because\n        // We've already installed them. Also, accessing them can throw in incognito mode.\n        const code = `\r\n      'use strict';\r\n      (function(){\r\n        ${workerDOMScript}\r\n        self['window'] = self;\r\n        var workerDOM = WorkerThread.workerDOM;\r\n        WorkerThread.hydrate(\r\n          workerDOM.document,\r\n          ${JSON.stringify(strings)},\r\n          ${JSON.stringify(skeleton)},\r\n          ${JSON.stringify(cssKeys)},\r\n          ${JSON.stringify(globalEventHandlerKeys)},\r\n          [${window.innerWidth}, ${window.innerHeight}],\r\n          ${JSON.stringify(localStorageInit)},\r\n          ${JSON.stringify(sessionStorageInit)}\r\n        );\r\n        workerDOM.document[${59 /* TransferrableKeys.observe */}](this);\r\n        Object.assign(self, workerDOM);\r\n      }).call(self);\r\n      ${authorScript}\r\n      //# sourceURL=${encodeURI(config.authorURL)}`;\n        if (!config.sandbox) {\n            this[55 /* TransferrableKeys.worker */] = new Worker(URL.createObjectURL(new Blob([code])));\n        }\n        else if (IS_AMP) {\n            this[55 /* TransferrableKeys.worker */] = new IframeWorker(URL.createObjectURL(new Blob([code])), config.sandbox.iframeUrl);\n        }\n        if (WORKER_DOM_DEBUG) {\n            console.info('debug', 'hydratedNode', readableHydrateableRootNode(baseElement, config, this));\n        }\n        if (config.onCreateWorker) {\n            config.onCreateWorker(baseElement, strings, skeleton, cssKeys);\n        }\n    }\n    /**\n     * Returns a Promise that resolves when the Worker is ready to receive messages.\n     * @returns {Promise<void>}\n     */\n    ready() {\n        return this.worker.readyPromise || Promise.resolve();\n    }\n    /**\n     * Returns the private worker.\n     */\n    get worker() {\n        return this[55 /* TransferrableKeys.worker */];\n    }\n    /**\n     * @param message\n     */\n    messageToWorker(message, transferables) {\n        if (WORKER_DOM_DEBUG) {\n            console.info('debug', 'messageToWorker', readableMessageToWorker(this.nodeContext, message));\n        }\n        if (this.config.onSendMessage) {\n            this.config.onSendMessage(message);\n        }\n        this.worker.postMessage(message, transferables || []);\n    }\n}\nfunction getStorageInit(type, sanitizer) {\n    try {\n        if (!sanitizer) {\n            return { storage: window[type], errorMsg: null };\n        }\n        return {\n            storage: sanitizer.getStorage(type == 'localStorage' ? 0 /* StorageLocation.Local */ : 1 /* StorageLocation.Session */),\n            errorMsg: null,\n        };\n    }\n    catch (err) {\n        return { errorMsg: err.message, storage: null };\n    }\n}\n//# sourceMappingURL=worker.js.map","/**\n * Stores objects that have their behavior handled from the main-thread. Each object is associated to a unique ID.\n */\nexport class ObjectContext {\n    objects;\n    constructor() {\n        this.objects = new Map();\n    }\n    store(id, obj) {\n        this.objects.set(id, obj);\n    }\n    get(id) {\n        const obj = this.objects.get(id);\n        if (obj) {\n            return obj;\n        }\n        else {\n            throw new Error('Object with id (' + id + ') does not exist.');\n        }\n    }\n}\n//# sourceMappingURL=object-context.js.map","import { registerPromise } from './commands/function';\n/**\n * An ExportedWorker is returned by the upgradeElement API.\n * For the most part, it delegates to the underlying Worker.\n *\n * It notably removes `postMessage` support and adds `callFunction`.\n */\nexport class ExportedWorker {\n    workerContext_;\n    config;\n    constructor(workerContext, config) {\n        this.workerContext_ = workerContext;\n        this.config = config;\n    }\n    /**\n     * Calls a function in the worker and returns a promise with the result.\n     * @param functionIdentifer\n     * @param functionArguments\n     */\n    callFunction(functionIdentifer, ...functionArguments) {\n        if (!this.config.executorsAllowed.includes(13 /* TransferrableMutationType.FUNCTION_CALL */)) {\n            throw new Error(`[worker-dom]: Error calling ${functionIdentifer}. You must enable the FUNCTION_CALL executor within the config.`);\n        }\n        const { promise, index } = registerPromise();\n        const msg = {\n            [12 /* TransferrableKeys.type */]: 12 /* MessageType.FUNCTION */,\n            [77 /* TransferrableKeys.functionIdentifier */]: functionIdentifer,\n            [78 /* TransferrableKeys.functionArguments */]: JSON.stringify(functionArguments),\n            [7 /* TransferrableKeys.index */]: index,\n        };\n        this.workerContext_.messageToWorker(msg);\n        return promise;\n    }\n    set onerror(handler) {\n        this.workerContext_.worker.onerror = handler;\n    }\n    terminate() {\n        this.workerContext_.worker.terminate();\n    }\n}\n//# sourceMappingURL=exported-worker.js.map","import { MutatorProcessor } from './mutator';\nimport { NodeContext } from './nodes';\nimport { StringContext } from './strings';\nimport { normalizeConfiguration } from './configuration';\nimport { WorkerContext } from './worker';\nimport { ObjectContext } from './object-context';\nimport { ExportedWorker } from './exported-worker';\nconst ALLOWABLE_MESSAGE_TYPES = [3 /* MessageType.MUTATE */, 2 /* MessageType.HYDRATE */];\n/**\n * @param baseElement\n * @param authorScriptURL\n * @param workerDOMURL\n * @param callbacks\n * @param sanitizer\n * @param debug\n */\nexport function fetchAndInstall(baseElement, config) {\n    const fetchPromise = Promise.all([\n        // TODO(KB): Fetch Polyfill for IE11.\n        fetch(config.domURL).then((response) => response.text()),\n        fetch(config.authorURL).then((response) => response.text()),\n    ]);\n    return install(fetchPromise, baseElement, config);\n}\n/**\n * @param fetchPromise\n * @param baseElement\n * @param config\n */\nexport function install(fetchPromise, baseElement, config) {\n    const mode = baseElement.dataset['shadowDom'];\n    if (mode === 'open' || mode === 'closed') {\n        const shadowRoot = baseElement.attachShadow({ mode });\n        const clonedElement = baseElement.cloneNode(true);\n        shadowRoot.appendChild(clonedElement);\n        baseElement = clonedElement;\n    }\n    const stringContext = new StringContext();\n    const objectContext = new ObjectContext();\n    const nodeContext = new NodeContext(stringContext, baseElement);\n    const normalizedConfig = normalizeConfiguration(config);\n    return fetchPromise.then(([domScriptContent, authorScriptContent]) => {\n        if (domScriptContent && authorScriptContent && config.authorURL) {\n            const workerContext = new WorkerContext(baseElement, nodeContext, domScriptContent, authorScriptContent, normalizedConfig);\n            const mutatorContext = new MutatorProcessor(stringContext, nodeContext, workerContext, normalizedConfig, objectContext);\n            workerContext.worker.onmessage = (message) => {\n                const { data } = message;\n                if (!ALLOWABLE_MESSAGE_TYPES.includes(data[12 /* TransferrableKeys.type */])) {\n                    return;\n                }\n                mutatorContext.mutate(data[54 /* TransferrableKeys.phase */], data[37 /* TransferrableKeys.nodes */], data[41 /* TransferrableKeys.strings */], new Uint16Array(data[36 /* TransferrableKeys.mutations */]));\n                if (config.onReceiveMessage) {\n                    config.onReceiveMessage(message);\n                }\n            };\n            return workerContext.ready().then(() => new ExportedWorker(workerContext, normalizedConfig));\n        }\n        return null;\n    });\n}\n//# sourceMappingURL=install.js.map","/**\n * @fileoverview This entry point API in active development and unstable.\n */\nimport { fetchAndInstall, install } from './install';\nimport { toLower } from '../utils';\n/**\n * AMP Element Children need to be filtered from Hydration, to avoid Author Code from manipulating it.\n * TODO: In the future, this contract needs to be more defined.\n * @param element\n */\nconst hydrateFilter = (element) => {\n    if (element.parentNode !== null) {\n        const lowerName = toLower(element.parentNode.localName || element.parentNode.nodeName);\n        return !/amp-/.test(lowerName) || lowerName === 'amp-script';\n    }\n    return true;\n};\n/**\n * @param baseElement\n * @param domURL\n */\nexport function upgradeElement(baseElement, domURL, longTask, sanitizer, sandbox) {\n    const authorURL = baseElement.getAttribute('src');\n    if (authorURL) {\n        return fetchAndInstall(baseElement, {\n            domURL,\n            authorURL,\n            longTask,\n            hydrateFilter,\n            sanitizer,\n            sandbox,\n        });\n    }\n    return Promise.resolve(null);\n}\n/**\n * @param baseElement\n * @param fetchPromise Promise that resolves containing worker script, and author script.\n */\nexport function upgrade(baseElement, fetchPromise, config) {\n    config.hydrateFilter = hydrateFilter;\n    return install(fetchPromise, baseElement, config);\n}\n//# sourceMappingURL=index.amp.js.map","export const toLower = (value) => value.toLowerCase();\nexport const toUpper = (value) => value.toUpperCase();\nexport const containsIndexOf = (pos) => pos !== -1;\nexport const keyValueString = (key, value) => `${key}=\"${value}\"`;\n//# sourceMappingURL=utils.js.map"],"names":["h","OffscreenCanvasProcessor","strings","objectContext","config","includes","execute","c","e","f","b","getNode","mutations","startPosition","d","messageToWorker","_index_","target","offscreen","DefaultAllowedMutations","A","a","Array","prototype","forEach","B","this","nodes","count","stringContext","baseElement","createNodes","buffer","sanitizer","nodeBufferLength","nodeBuffer","Uint16Array","length","node","iterator","nodeName","get","nodeListEach","Map","BASE_ELEMENT_INDEX","monitoredNodes","applyDefaultInputListener","workerContext","sendValueChangeOnAttributeMutation","attributes","fireValueChange","value","Object","createTransferrableTouchList","values","map","identifier","screenX","screenY","clientX","clientY","pageX","touch","pageY","EventSubscriptionProcessor","k","executorsAllowed","preventDefault","currentTarget","event","p","type","innerHeight","window","cachedWindowSize","innerWidth","fireResizeChange","bubbles","m","n","l","q","endPosition","addEventListenersPosition","addEventListenerCount","allowedMutation","w","J","isRemoveEvent","eventIndex","r","addEventListener","removeEventListener","inputEventSubscribed","oninput","isChangeEvent","BoundingClientRectProcessor","allowedExecution","boundingRect","getBoundingClientRect","top","right","bottom","left","width","height","ChildListProcessor","appendNodeCount","removeNodeCount","slice","removeId","remove","addId","nextSibling","newNode","insertBefore","AttributeProcessor","attributeName","setAttribute","removeAttribute","CharacterDataProcessor","textContent","PropertyProcessor","nodeContext","name","setProperty","String","LongTaskExecutor","currentResolver","longTask","index","newResolver","Promise","resolve","then","active","f32","Float32Array","u16","R","offset","args","size","des","deserializeTransferrableObject","ObjectMutationProcessor","functionName","argCount","targetOffset","deserializedTarget","argsOffset","isSetter","ObjectCreationProcessor","Error","objectId","store","ImageBitmapProcessor","self","createImageBitmap","imageBitmap","StorageProcessor","operation","valueIndex","key","keyIndex","location","message","storage","localStorage","sessionStorage","fnCallCount","promiseMap","registerPromise","FunctionProcessor","status","parsed","hasIndex","JSON","parse","undefined","reject","ScrollIntoViewProcessor","scrollIntoView","ka","executors","mutationPumpFunction","syncFlush","allowVisibleMutations","mutationQueue","mutationArray","mutationType","operationStart","mutationPump","M","N","apply","O","aa","I","L","v","ea","fa","mutate","storeValues","pendingMutations","push","NODES_ALLOWED_TO_TRANSMIT_TEXT_CONTENT","createHydrateableNode","element","minimizeString","hydrateFilter","filteredChildNodes","call","childNodes","filter","child","namespaceURI","attribute","g","nodeType","hydrated","pa","readyPromiseResolve","iframe","readyPromise","onmessageerror","onmessage","onerror","url","setupInit","data","msg","code","proxyFromWorker","_extends","contentWindow","postMessage","transferables","WorkerContext","createHydrateableRootNode","stringMap","has","localStorageInit","getStorageInit","sessionStorageInit","style","cssKeys","startsWith","globalEventHandlerKeys","workerDOMScript","stringify","skeleton","authorScript","sandbox","Worker","URL","createObjectURL","Blob","ready","ObjectContext","objects","obj","sa","callFunction","functionIdentifer","T","Number","MAX_VALUE","workerContext_","install","fetchPromise","mode","dataset","shadowDom","shadowRoot","attachShadow","clonedElement","cloneNode","StringContext","normalizedConfig","normalizeConfiguration","domScriptContent","authorScriptContent","authorURL","mutatorContext","MutatorProcessor","parentNode","lowerName","localName","toLowerCase","getAttribute","all","fetch","ua","upgradeElement"],"mappings":"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"}